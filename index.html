<!DOCTYPE html>
<html>

<head>
    <title>Editor</title>
    <meta charset="utf-8"/>

    <link rel="stylesheet" href="normalize.css">

    <script src="bundle.js"></script>
    <script src="monaco-editor/min/vs/loader.js"></script>

    <style>
        #new-room, .container {
            display: none;
        }

        .container {
            display: grid;
            grid-template-columns: auto 200px;
            height: 100vh;
        }

        #peers {
            overflow: hidden;
        }
    </style>
</head>

<body>

    <button id="new-room">New</button>

    <div class="container">
        <div id="editor"></div>

        <div>
            <h3>Set Language</h3>
            <select id="languages">
            </select>

            <h3>Peers</h3>
            <ul id="peers"></ul>
        </div>
    </div>

<script>
(function() {

    // generate a random sequence of characters
    function makeId() {
        let result = [];
        const characters = '0123456789abcdef';
        for (let i = 0; i < 40; i++)
            result.push(characters[Math.floor(Math.random() * characters.length)]);
        return result.join('');
    }

    let discovery = null;
    const peerId = makeId();
    let connections = {};
    let name = null;
    let connectionNames = {};
    let editor = null;
    let editorModel = null;
    let trackingChanges = true;

    console.log('peerId:', peerId);

    function updatePeersDisplay() {
        const frags = [`<li>${ name }<\/li>`];
        for (const peerId in connectionNames) {
            const name = connectionNames[peerId];
            frags.push(`<li>${ name }<\/li>`);
        }
        document.querySelector('#peers').innerHTML = frags.join('');
    }

    window.addEventListener('load', async function() {
        const newButton = document.querySelector('#new-room');
        newButton.addEventListener('click', createRoom, false);

        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room');

        if (!roomId) {
            newButton.style.display = 'block';
            return;
        }

        joinRoom(roomId);

        // create the editor
        require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
        require(['vs/editor/editor.main'], function() {

            // populate langauges list
            document.querySelector('#languages').innerHTML = monaco.languages.getLanguages().map(lang =>
                `<option value="${ lang.id }">${ lang.aliases[0] }<\/option>`
            ).join('');

            editor = monaco.editor.create(document.getElementById('editor'), {
                value: '',
                language: 'plaintext'
            });
            console.log('editor:', editor);

            editorModel = editor.getModel();
            const languagesSelect = document.querySelector('#languages');
            languagesSelect.addEventListener('change', (event) => {
                monaco.editor.setModelLanguage(editorModel, languagesSelect.value);
            });
            console.log('model:', editorModel);

            editorModel.onDidChangeContent(event => {
                console.log('change:', event);
                if (!trackingChanges)
                    return;
                broadcast({type: 'edits', value: event.changes});
            });
        });
    }, false);

    window.addEventListener('beforeunload', function() {
        for (let peerId in connections) {
            const peer = connections[peerId];
            peer.destroy();
        }
    });

    function createRoom() {
        window.location.href = window.location.pathname + '?room=' + makeId();
    }

    function joinRoom(roomId) {
        const cachedName = localStorage.getItem('editor-name');
        if (cachedName == null)
            name = prompt('Your name is...');
        else
            name = prompt('Your name is...', cachedName);
        localStorage.setItem('editor-name', name);
        updatePeersDisplay();

        discovery = new Discovery({
            infoHash: roomId,
            peerId: peerId,
            announce: ['wss://tracker.openwebtorrent.com'],
        });
        console.log('discovery:', discovery);
        discovery.on('warning', console.warn);
        discovery.on('error', console.error);
        discovery.on('peer', (peer, _source) => {
            console.log('peer:', peer);
            if (peer.id.length !== 40 || connections.hasOwnProperty(peer.id))
                return;

            peer.on('connect', () => {
                console.log('readyState', peer._channel.readyState);
                setupConnection(peer);
                updatePeersDisplay();
            });
        });
    }

    function setupConnection(peer) {
        const peerId = peer.id
        connections[peerId] = peer;
        // connectionNames[peerId] = peerId;

        peer.on('data', receiveData.bind(this, peerId));
        peer.on('close', () => {
            console.log('peer closed:', peer.id);
            delete connections[peer.id];
            delete connectionNames[peer.id];
            updatePeersDisplay();
        });
        peer.on('error', err => {
            if (!connections.hasOwnProperty(peer.id))
                return;
            console.error('peer error:', err);
        });

        peer.send(JSON.stringify({type: 'greet', value: name}));
        const existingValue = editorModel.getValue();
        if (existingValue.length > 0)
            peer.send(JSON.stringify({type: 'state', value: existingValue}));
    }

    function broadcast(data) {
        console.log('broadcasting to:', connections);
        const data_ = JSON.stringify(data);
        for (let peerId in connections) {
            const peer = connections[peerId];
            try {
                peer.send(data_);
            } catch {
            }
        }
    }

    function receiveData(peerId, data) {
        data = JSON.parse(new TextDecoder('utf-8').decode(data));
        console.log('incoming:', data);

        if (data.type === 'edits') {
            const edits = data.value;
            for (let edit of edits)
                edit.forceMoveMarkers = true;

            trackingChanges = false;
            editorModel.pushEditOperations([], edits);
            trackingChanges = true;
            console.log('incoming done');
        } else if (data.type === 'greet') {
            const value = data.value;
            connectionNames[peerId] = value;
            updatePeersDisplay();
        } else if (data.type === 'state') {
            trackingChanges = false;
            editorModel.setValue(data.value);
            trackingChanges = true;
        }
    }

})();

</script>
</body>
</html>
